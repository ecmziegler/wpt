<!DOCTYPE html>
<meta charset=utf-8>
<title>Test element-based scroll offset for scroll timeline.</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/web-animations/testcommon.js"></script>
<style>
  .scroller {
    overflow: auto;
    height: 100px;
    width: 100px;
  }
  .contents {
    height: 2000px;
    width: 100%;
    position: relative;
  }

  #start, #end {
    background: blue;
    width: 100%;
    height: 50px;
  }

  #start {
    position: absolute;
    top: 50px;
  }

  #end {
    position: absolute;
    top: 1050px;
  }

</style>
<div id="log"></div>
<script>
  'use strict';

  function createScrollerWithStartAndEnd(test) {
    var scroller = createDiv(test);
    scroller.innerHTML =
     `<div class='contents'>
        <div id='start'>Start</div>
        <div id='end'>End</div>
      </div>`;
    scroller.classList.add('scroller');
    return scroller;
  }

  function createScrollTimeline(test, options) {
    options = options || {
      scrollSource: createScrollerWithStartAndEnd(test),
      timeRange: 1000
    }
    return new ScrollTimeline(options);
  }

  function createScrollLinkedAnimation(test, timeline) {
    if(timeline === undefined)
      timeline = createScrollTimeline(test);
    const DURATION = 1000; // ms
    const KEYFRAMES = { opacity: [1, 0] };
    return new Animation(
      new KeyframeEffect(createDiv(test), KEYFRAMES, DURATION), timeline);
  }

  async function createScrollAnimationTest(name, config) {
    promise_test(async t => {

    const scroller = createScrollerWithStartAndEnd(t);
    t.add_cleanup(() => scroller.remove());

    const start = scroller.querySelector("#start");
    const end = scroller.querySelector("#end")

    const timeline = createScrollTimeline(t, {
      scrollSource: scroller,
      timeRange: 1000,
      fill: 'both',
      startScrollOffset : { target: start, ...config.start},
      endScrollOffset : { target: end, ...config.end }
    });

    const animation = createScrollLinkedAnimation(t, timeline);

    const scrollRange = end.offsetTop - start.offsetTop;
    const timeRange = animation.timeline.timeRange;

    // Verify initial start and current times in Idle state.
    assert_equals(animation.currentTime, null,
      "The current time is null in Idle state.");
    assert_equals(animation.startTime, null,
      "The start time is null in Idle state.");

    animation.play();
    // Verify initial start and current times in Pending state.
    assert_times_equal(animation.currentTime, 0,
      "The current time is a hold time in Pending state.");
    assert_equals(animation.startTime, null,
      "The start time is null in Pending state.");

    await animation.ready;
    // Verify initial start and current times in Playing state.
    assert_times_equal(animation.currentTime, 0,
      "The current time is zero in Playing state.");
    assert_times_equal(animation.startTime, 0,
      "The start time is zero in Playing state.");

    // Now do some scrolling and make sure that the Animation current time is
    // correct.
    scroller.scrollTo(config.scrollTo);
    assert_equals(scroller.scrollTop, config.scrollTo.top);

    await waitForNextFrame();
    assert_times_equal(animation.timeline.currentTime, config.expectedCurrentTime,
      "The timeline current time corresponds to the scroll position of the scroller.");
    assert_times_equal(animation.currentTime, config.expectedCurrentTime,
      "The animation current time corresponds to the scroll position of the scroller.");
    assert_times_equal(
      animation.effect.getComputedTiming().localTime,
      config.expectedCurrentTime,
      'Effect local time corresponds to the scroll position of the scroller.');

    }, `Animation start and current times are correct given element-based offsets for testcase ${name}.`);
  }

  // start is @   50px
  // edge is  @ 1050px
  //   both have 50px heights
  // scroller has 100px heights
  const tests = {
    "at start": {
      scrollTo: {top: 50},
      expectedCurrentTime: 0,
    },
    "after start": {
      scrollTo: {top: 150},
      expectedCurrentTime: 100,
    },
    "at middle" : {
      scrollTo: {top: 550},
      expectedCurrentTime: 500,
    },
    "at end" : {
      scrollTo: {top: 1049},
      expectedCurrentTime: 999,

    },
    "after end" : {
      scrollTo: {top: 1150},
      expectedCurrentTime: 1000,

    },
    "with threshold" : {
      start : {
        threshold: 0.5
      },
      end : {
        // give threshold to both start and end to keep scrollRange
        // 1000 which simplifies the calculation.
        threshold: 0.5
      },
      scrollTo: {top: 175},
      expectedCurrentTime: 100,
    },
    "with edge" : {
      end : {
        threshold: 0.0,
        edge: "end"
      },
      scrollTo: {top: 1050 - 100},
      expectedCurrentTime: 1000,
    }
  };

  for (test in tests) {
    createScrollAnimationTest(test, tests[test]);
  }

</script>